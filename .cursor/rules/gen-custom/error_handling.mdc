---
description: Error handling patterns and logging conventions
globs:
  - "**/*.py"
alwaysApply: true
---

NOTE: This rule file was generated or updated by the `/rules-architect` command.

## Error Handling Patterns

### Exception Handling Strategy

- Use **guard clauses** at the beginning of functions to validate inputs.
- Use **early returns** for error conditions to avoid deeply nested code.
- Place the **happy path last** in functions for improved readability.
- Avoid unnecessary `else` statements after early returns.

### Logging

- Use the `logging` module with module-level loggers: `logger = logging.getLogger(__name__)`.
- Use appropriate log levels:
  - `logger.debug()` - Detailed information for debugging.
  - `logger.info()` - General informational messages.
  - `logger.warning()` - Warning messages for potential issues.
  - `logger.error()` - Error messages for handled exceptions.
  - `logger.exception()` - Exception details with stack trace.
- Include structured context in log messages (module, function, parameters).
- Use f-strings or `%` formatting for log messages.

### Database Error Handling

- Always use try-except blocks around database operations.
- Roll back transactions on exceptions: `_db_session.rollback()`.
- Commit transactions only on success: `_db_session.commit()`.
- Log exceptions with `logger.exception()` to capture stack traces.
- Return appropriate default values (e.g., `pd.DataFrame([])`, `None`) on errors.

```python
try:
    # Database operation
    _db_session.commit()
    logger.debug("Operation completed successfully.")
except Exception as exc:
    logger.exception("Operation failed due to: %s", exc)
    _db_session.rollback()
    return pd.DataFrame([])  # or None, or raise
```

### Validation Errors

- Use Pydantic validators for input validation.
- Raise `ValueError` or `TypeError` for invalid inputs with descriptive messages.
- Use `model_validator` for complex validation logic.
- Use `field_validator` for field-level validation.

```python
@model_validator(mode="after")
def _validate_model(self) -> Self:
    if self.start_date > self.end_date:
        raise ValueError("start_date must be before end_date")
    return self
```

### Custom Exceptions

- Create custom exception classes for domain-specific errors when appropriate.
- Inherit from appropriate base exceptions (`ValueError`, `TypeError`, `RuntimeError`).
- Include descriptive error messages with context.

### Error Messages

- Use clear, descriptive error messages.
- Include relevant context (IDs, values, expected types).
- Avoid exposing sensitive information in error messages.
- Use consistent error message formatting.

### Repository Error Handling

- Check for empty results before processing: `if getattr(records, "empty", True):`
- Log warnings for expected edge cases (e.g., no records to delete).
- Return empty DataFrames or None for "not found" scenarios.
- Raise exceptions only for unexpected errors.

### Service Error Handling

- Validate DTO types using `check_expected_dto_type()`.
- Handle both DTO instances and dictionaries gracefully.
- Raise `TypeError` for type mismatches.
- Raise `ValueError` for invalid business logic.
- Raise `RuntimeError` for operational failures (e.g., upsert tolerance exceeded).

### Handler Error Handling

- Validate dependencies exist before use.
- Raise `ValueError` for missing dependencies.
- Raise `TypeError` for invalid DTO types.
- Raise `ValueError` for missing required data (e.g., "No data loaded to dump").

### Graceful Degradation

- Return empty results (`pd.DataFrame([])`, `None`) instead of raising exceptions when appropriate.
- Log warnings for recoverable errors.
- Only raise exceptions for unrecoverable errors.
- Use default values for optional parameters.
